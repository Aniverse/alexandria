#!/usr/bin/env python
import re
import os
import sys
import base64
import pprint
import shutil
import urllib
import argparse
import itertools
import subprocess
import unicodedata
import multiprocessing
from _version import __version__

try:
    import ConfigParser
except ImportError:
    import configparser as ConfigParser

try:
    from HTMLParser import HTMLParser
except ImportError:
    from html.parser import HTMLParser

import requests
import lxml.html
import epub
import mobi

HEADERS = {
    'Connection': 'keep-alive',
    'Cache-Control': 'max-age=0',
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3)'\
        'AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.79'\
        'Safari/535.11',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9'\
        ',*/*;q=0.8',
    'Accept-Encoding': 'gzip,deflate,sdch',
    'Accept-Language': 'en-US,en;q=0.8',
    'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.3'
}

MIMETYPES = {
    'application/pdf': '.pdf',
    'application/epub+zip': '.epub',
    'image/vnd.djvu': '.djvu',
}

TAGS = {
    "art",
    "artificial.intelligence",
    "autobiography",
    "biography",
    "biology",
    "business",
    "chemistry",
    "children",
    "computer.science",
    "computing",
    "crafts",
    "crime",
    "culture",
    "design",
    "diy",
    "economics",
    "education",
    "entertainment",
    "fantasy",
    "fashion",
    "fiction",
    "finance",
    "food",
    "gaming",
    "guns",
    "health",
    "history",
    "hobbies",
    "home.and.garden",
    "horror",
    "human.interface",
    "humor",
    "language",
    "linguistics",
    "mathematics",
    "medicine",
    "men",
    "music",
    "mystery",
    "nature",
    "news",
    "non.fiction",
    "paranormal",
    "parenting",
    "philosophy",
    "photography",
    "physics",
    "politics",
    "pop.culture",
    "programming",
    "reference",
    "religion",
    "romance",
    "science",
    "science.fiction",
    "software.engineering",
    "sports",
    "technology",
    "teen",
    "thriller",
    "travel",
    "vehicles",
    "war",
    "women",
}

BANNER = '\n\nCreated with [url=https://github.com/pthcode/alexandria]alexandria[/url] version %s.'

class Tracker(object):
    def __init__(self, username, password):
        self.session = requests.Session()
        self.session.headers.update(HEADERS)
        self.session.verify = False # for self-signed SSL certificates
        self.login(username, password)

class Bibliotik(Tracker):
    name = "Bibliotik"
    formats = {
        '.pdf': '2',
        '.mobi': '16',
        '.epub': '15',
        '.djvu': '4',
    }
    languages = {
        'eng': '1',
        'deu': '2',
        'fra': '3',
        'spa': '4',
        'ita': '5',
        'jap': '7',
        'swe': '8',
        'rus': '13',
    }

    def login(self, username, password):
        params = {'username': username, 'password': password}
        self.session.post('http://bibliotik.org/login', params)

        r = self.session.get('http://bibliotik.org/upload/ebooks')
        doc = lxml.html.fromstring(r.text)
        self.authkey = doc.xpath('//*[@id="body"]/form/input[2]')[0].attrib['value']
        self.announce = doc.xpath('//*[@id="body"]/p/input')[0].attrib['value']
        self.name = "Bibliotik"

    def upload(self, filename, torrent, metadata):
        files = {'TorrentFileField': open(torrent, 'rb')}
        isbn = metadata['isbn']
        try:
            # use bibliotik's isbn canonicalization
            isbn = self.fetch_metadata(isbn)['isbn']
        except:
            pass
        data = {
            'upload': '',
            'authkey': self.authkey,
            'AuthorsField': metadata['authors'],
            'TitleField': metadata['title'],
            'IsbnField': isbn,
            'PublishersField': metadata['publisher'],
            'PagesField': metadata.get('pages') or '',
            'YearField': metadata['year'],
            'FormatField': self.formats[os.path.splitext(filename)[-1]],
            'LanguageField': self.languages[metadata['language']],
            'TagsField': metadata['tags'] or 'nonfiction',
            'ImageField': metadata['image'],
            'DescriptionField': (metadata['description'].decode('utf-8') + BANNER).encode('utf-8'),
        }

        r = self.session.post('http://bibliotik.me/upload/ebooks', files=files, data=data)
        return True

    def fetch_metadata(self, isbn):
        params = {'isbn': isbn, 'authkey': self.authkey}
        r = self.session.get('http://bibliotik.me/isbnlookup', params=params)
        data = r.json()
        if 'isbn' in data:
            return data
        return None

    def has_book(self, metadata):
        isbn = metadata['isbn']
        try:
            # use bibliotik's isbn canonicalization
            isbn = self.fetch_metadata(isbn)['isbn']
        except:
            pass
        params = {'search': '@isbn %s' % isbn}
        r = self.session.get('http://bibliotik.me/torrents/', params=params)
        return 'No torrents found.' not in r.text

class PTH(Tracker):
    name = "PTH"

    def login(self, username, password):
        params = {'username': username, 'password': password}
        self.session.post('https://passtheheadphones.me/login.php', params)

        r = self.session.get('https://passtheheadphones.me/upload.php')
        doc = lxml.html.fromstring(r.text)
        self.authkey = doc.xpath('//*[@id="upload_table"]/div[1]/input[2]')[0].attrib['value']
        self.announce = doc.xpath('//*[@id="content"]/div[2]/p/input')[0].attrib['value']

    def upload(self, filename, torrent, metadata):
        files = {'file_input': open(torrent, 'rb')}
        data = {
            'submit': 'true',
            'auth': self.authkey,
            'type': '2',
            'title': "%s - %s" % (metadata['authors'], metadata['title']),
            'tags': metadata['tags'] or 'non.fiction',
            'image': metadata['image'],
            'desc': (metadata['description'].decode('utf-8') + BANNER).encode('utf-8'),
        }

        r = self.session.post('https://passtheheadphones.me/upload.php', files=files, data=data)
        return True

    def has_book(self, metadata):
        params = {'searchstr': metadata['title'], 'filter_cat[3]': 1}
        r = self.session.get('https://passtheheadphones.me/torrents.php', params=params)
        return 'Your search did not match anything.' not in r.text

class HTML2BBCode(HTMLParser):
    def handle_starttag(self, tag, attrs):
        if tag == 'li':
            self.data.append('* ')
        elif tag == 'a':
            attrs = dict(attrs)
            self.data.append('[url=%s]' % attrs.get('href'))
        elif tag == 'img':
            attrs = dict(attrs)
            self.data.append('[img]%s[/img]' % attrs.get('src'))
        elif tag == 'em':
            self.data.append('[i]')
        elif tag in ['b', 'strong', 'h1', 'h2', 'h3', 'h4']:
            self.data.append('[b]')
        elif tag == 'code':
            self.data.append('[code]')
        elif tag == 'blockquote':
            self.data.append('[quote]')

    def handle_endtag(self, tag):
        if tag == 'ul':
            self.data.append('\n')
        elif tag == 'li':
            self.data.append('\n')
        elif tag == 'a':
            self.data.append('[/url]')
        elif tag == 'em':
            self.data.append('[/i]')
        elif tag in ['b', 'strong']:
            self.data.append('[/b]')
        elif tag in ['h1', 'h2', 'h3', 'h4']:
            self.data.append('[/b]\n\n')
        elif tag == 'code':
            self.data.append('[/code]')
        elif tag == 'blockquote':
            self.data.append('[/quote]')
        elif tag in ['br', 'p']:
            self.data.append('\n\n')

    def handle_data(self, data):
        self.data.append(data)

    def feed(self, data):
        self.data = []
        HTMLParser.feed(self, data)
        return u''.join(self.data)

def locate(root, match_function):
    for path, dirs, files in os.walk(root):
        for filename in itertools.ifilter(match_function, (os.path.abspath(os.path.join(path, filename)) for filename in files)):
            yield filename

def is_book(filename):
    return determine_format(filename) is not None

def determine_format(filename):
    extension = os.path.splitext(filename)[-1].lower()
    if extension in ['.epub', '.mobi', '.pdf', '.djvu']:
        return extension

    mimetype = subprocess.check_output(['file', '-b', '-i', filename]).split(';')[0]
    try:
        return MIMETYPES[mimetype]
    except Exception as e:
        return None

def create_tempfile(suffix):
    return subprocess.check_output(['mktemp', '-u', '--suffix', suffix]).strip()

def make_torrent(filename, announce, tracker_name, piece_size=16):
    torrent = create_tempfile('.torrent')
    if tracker_name == PTH.name:
        command = ['mktorrent', '-p', '-s', tracker_name, '-a', announce, '-l', str(piece_size), '-o', torrent, filename]
    else: # not sure if biblotik needs/wants the source filled in
        command = ['mktorrent', '-p', '-a', announce, '-l', str(piece_size), '-o', torrent, filename]
    subprocess.check_output(command, stderr=subprocess.STDOUT)
    return torrent

_slugify_strip_re = re.compile(r'[^\w\s-]')
_slugify_hyphenate_re = re.compile(r'[-\s]+')
def tagify(value):
    if not isinstance(value, unicode):
        value = unicode(value)
    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')
    value = unicode(_slugify_strip_re.sub('', value).strip().lower())
    return _slugify_hyphenate_re.sub('.', value)

def parse_tags(tags):
    tags = [tagify(tag) for tag in tags.split(', ')]
    return ', '.join(tag for tag in tags if tag in TAGS)

def html_to_bbcode(html):
    parser = HTML2BBCode()
    return parser.feed(html)

def upload_image(filename):
    try:
        return imgur_upload(filename)
    except:
        return baconbits_upload(filename)

def imgur_upload(filename):
    with open(filename, 'rb') as f:
        image = base64.b64encode(f.read())
        data = {'key': '4fc3866b77c289934bd83e324b16e1e0', 'image': image}
        r = requests.post("http://api.imgur.com/2/upload.json", data=data, verify=False)
        return r.json()['upload']['links']['original']

def baconbits_upload(filename):
    with open(filename, 'rb') as f:
        files = {'ImageUp': (os.path.basename(filename), f)}
        data = {
            'Filename': os.path.basename(filename),
            'fileext': '*.jpg;*.jpeg;*.png;*.gif;*.bmp',
            'Upload': 'Submit Query',
            'folder': '/',
            'sID': 'v851uqaj1hn3lb8dogqrsfo8p7',
        }
        r = requests.post('https://images.baconbits.org/upload.php', data=data, files=files)
        return "https://images.baconbits.org/images/%s" % r.json()['ImgName']

def fetch_metadata(isbn):
    try:
        cover = create_tempfile('.jpg')
        command = ['fetch-ebook-metadata', '-i', isbn, '-c', cover]
        output = subprocess.check_output(command, stderr=subprocess.PIPE)
        parsed = re.findall('([\w\(\)]+)\s+:\s(.*)', output)
        result = {re.sub('\W', '', key).lower(): value for key, value in parsed}
        return {
            'title': result['title'],
            'authors': result['authors'].replace(' & ', ', '),
            'publisher': result['publisher'],
            'tags': parse_tags(result.get('tags', '')),
            'language': result['languages'],
            'year': result['published'][:4],
            'isbn': re.search('isbn:(\d+)', result['identifiers']).group(1),
            'description': html_to_bbcode(result['comments'].decode('utf-8')).encode('utf-8'),
            'image': upload_image(cover),
        }
    except:
        return None

def parse_config(config_path):
    config = ConfigParser.SafeConfigParser()

    if os.path.isfile(config_path):
        config.read(config_path)
    else:
        config_dir = os.path.dirname(config_path)
        if not os.path.isdir(config_dir):
            os.makedirs(config_dir)

        config.add_section('global')
        config.set('global', 'torrent_dir', '')
        config.set('global', 'data_dir', '')

        config.add_section('bibliotik')
        config.set('bibliotik', 'username', '')
        config.set('bibliotik', 'password', '')

        config.add_section('pth')
        config.set('pth', 'username', '')
        config.set('pth', 'password', '')

        with open(config_path, 'w') as f:
            config.write(f)

        print('Please edit the configuration file: %s' % config_path)
        sys.exit(2)

    return config

def extract_isbn(filename):
    match = re.search('(\d{13}|\d{10})', filename)
    if match:
        return match.group()

    data_format = determine_format(filename)
    if data_format == '.pdf':
        command = ['pdftotext', '-f', '1', '-l', '10', filename, '-']
        text = subprocess.check_output(command, stderr=subprocess.PIPE)
        match = re.search('(?:[0-9]{3}-)?[0-9]{1,5}-[0-9]{1,7}-[0-9]{1,6}-[0-9]', text)
        if match:
            return match.group().replace('-', '')
    elif data_format == '.mobi':
        b = mobi.Book(filename)
        try:
            return b.exth['isbn'][0]
        except:
            pass
    elif data_format == '.epub':
        r = epub.EpubMetaReader(filename)
        meta = r.get_metadata()
        identifier = meta['identifier'][0].value
        match = re.search('(\d{13}|\d{10})', identifier)
        if match:
            return match.group()
    elif data_format == '.djvu':
        command = ['djvused', filename, '-e', 'print-pure-txt']
        text = subprocess.check_output(command, stderr=subprocess.PIPE)
        match = re.search('(?:[0-9]{3}-)?[0-9]{1,5}-[0-9]{1,7}-[0-9]{1,6}-[0-9]', text)
        if match:
            return match.group().replace('-', '')

    return None

def rename_ebook(original, output_dir, metadata):
    extension = determine_format(original)
    new_filename = "%s (%s)%s" % (metadata['title'], metadata['isbn'], extension)
    valid_chars = '-_.() abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    new_filename = os.path.join(output_dir, ''.join(c for c in new_filename if c in valid_chars))
    shutil.copy(original, new_filename)
    return new_filename

def upload(filename, config, trackers):
    isbn = extract_isbn(filename)
    if not isbn:
        print()
        print("Failed to extract ISBN from:", filename)
        return

    try:
        if all(tracker.has_book({'isbn': isbn}) for tracker in trackers):
            return
    except:
        return

    print
    metadata = fetch_metadata(isbn)
    if not metadata:
        print("Failed to fetch metadata for %s: %s" % (isbn, filename))
        return

    print("Book found: %s (%s) [%s]" % (metadata['title'], metadata['year'], determine_format(filename)[1:].upper()))
    ebook = rename_ebook(filename, os.path.expanduser(config.get('global', 'data_dir')), metadata)

    for i, tracker in enumerate(trackers):
        if tracker.has_book(metadata):
            print("%s already has it." % tracker.name)
            continue

        print("Uploading to %s..." % tracker.name),

        # create each tracker's torrent with a different piece size so
        # that the torrents each have different info hashes (otherwise only one will seed in rtorrent)
        torrent = make_torrent(ebook, tracker.announce, tracker.name, piece_size=15+i)

        if not tracker.upload(ebook, torrent, metadata):
            print("failed!")
            continue

        shutil.copy(torrent, os.path.expanduser(config.get('global', 'torrent_dir')))
        print("done!")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('book_dirs', nargs='+', help='paths to directories containing books')
    parser.add_argument('--config', help='the location of the configuration file', \
            default=os.path.expanduser('~/.alexandria/config'))

    args = parser.parse_args()
    config = parse_config(args.config)

    trackers = []
    for tracker in [Bibliotik, PTH]:
        username = config.get(tracker.__name__.lower(), 'username')
        password = config.get(tracker.__name__.lower(), 'password')
        if username and password:
            print("Logging into %s." % tracker.name)
            trackers.append(tracker(username, password))

    books = itertools.chain(*(locate(book_dir, is_book) for book_dir in args.book_dirs))
    for filename in books:
        upload(filename, config, trackers)

if __name__ == '__main__': main()
